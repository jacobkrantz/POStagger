import sys
import numpy as np
np.set_printoptions(threshold=np.nan)

class POStagger:

    # load required data structures
    def __init__(self):
        self.__wordLookup = self.__getLookup("./wordSets/wordLookup.txt")
        self.__tagLookup = self.__getLookup("./wordSets/tagLookup.txt")
        self.__tagProb = self.__getTagProb("./wordSets/tagProb.txt")
        self.__matrixA = self.__getMatrix("./wordSets/matrixA.txt")
        self.__matrixB = self.__getMatrix("./wordSets/matrixB.txt")
        self.__iMax = len(self.__tagLookup)


    # tags a sequence of observations with their cooresponding POS tag.
    # tagLst is a list of single observations.
    def tagSequence(self, obsLst):
        self.__obs = obsLst
        self.__jMax = len(self.__obs)
        taggedSequence = []

        isValid,problemWord = self.__isValidObs()

        if(isValid):

            matrixV,matrixP = self.__buildMatrixV()
            tagSeq = self.__getOutput(matrixV,matrixP)
            # self.__printOutput(tagSeq)
            taggedSequence = self.__buildTups(tagSeq)

        else:
            print("Error: '" + problemWord + "' does not exist in training set.")

        return taggedSequence


    # tags an entire file with their POS tags.
    # separates file into sequences. These chunks are then passed into
    # 'tagSequence()'. All tagged sequences are then combined to form output.
    # Returns the list of tagged sequences while also outputting to a file.
    def tagAllFile(self, testFile, outFile):
        finalTups = []

        AllObs = self.__getFileContents(testFile)
        AllObs = self.__splitObs(AllObs)

        for sequence in AllObs:
            finalTups.append(self.tagSequence(sequence))

        self.__outputTaggedSeq(outFile, finalTups)
        return finalTups


    #----------------------------
    #      Private Functions
    #----------------------------


    #inputs a matrix from a file, generated by numpy
    def __getMatrix(self, fileName):
        try:
            matrix = np.loadtxt(fileName, dtype = 'float')
        except:
            print(fileName +" does not exist or is corrupt. try running buildMatrices.py")
            sys.exit(0)
        return matrix


    #imports the lookup list for a given item (either tags or words)
    def __getLookup(self, fileName):
        lookup = []
        try:
            rawFile = open(fileName,'r')
            for line in rawFile:
                item = line.strip('\n')
                lookup.append(item)
        except IOError:
            print(fileName + " does not exist or is corrupt.")
            sys.exit(0)
        return lookup


    #imports a file containing a dictionary where KEY=tag VALUE=tagCount
    def __getTagProb(self, fileName):
        tagProb = {}
        try:
            tagFile = open(fileName,'r')
            for line in tagFile:
                newLine = line.split(' ')
                tagProb[newLine[0]] = float(newLine[1])
        except IOError:
            print(fileName + " does not exist or is corrupt.")
            sys.exit(0)
        return tagProb


    #checks if all entered observations exist in the HMM
    def __isValidObs(self):
        try:
            for i in range(0,self.__jMax): # len obs
                problemWord = self.__obs[i]
                self.__wordLookup.index(self.__obs[i])

        except ValueError:
            return False, problemWord

        return True, ''


    #constructs Viterbi and backpointer matrices for determining correct tag sequence
    def __buildMatrixV(self):

        matrixV = np.zeros((self.__iMax,self.__jMax), dtype=np.float) # Viterbi matrix
        matrixP = np.zeros((self.__iMax,self.__jMax), dtype='int,int') # backpointer matrix

        for i in range(0,self.__iMax):                #initialization step
            obsIndex = self.__wordLookup.index(self.__obs[0])
            matrixV[i,0] = self.__matrixB[i,obsIndex]

        for j in range(1,self.__jMax):                #iterative step
            obsWord = self.__wordLookup.index(self.__obs[j])
            for i in range(0,self.__iMax):
                curProb = 0
                maxProb = 0
                iBack = 0
                jBack = 0
                for oldI in range(0,self.__iMax):
                    Bword = self.__wordLookup[j]
                    curProb = matrixV[oldI,j-1] * self.__matrixA[oldI,i] * self.__matrixB[i,obsWord]

                    if (curProb > maxProb):
                        maxProb = curProb
                        iBack = oldI
                        jBack = j - 1

                matrixV[i,j] = maxProb
                matrixP[i,j][0] = iBack
                matrixP[i,j][1] = jBack

        return matrixV, matrixP


    #traces through the backpointer matrix P and catches
    #the most likely tag sequence as it iterates
    def __getOutput(self, matrixV, matrixP):
        revOutput = []

        maxFinal = 0
        iFinal = 0

        for i in range(0,self.__iMax):         #only grabs final max prob
            currentFinal = matrixV[i,self.__jMax - 1]
            if(currentFinal > maxFinal):
                maxFinal = currentFinal
                iFinal = i

        revOutput.append(self.__tagLookup[iFinal])
        iCur = matrixP[iFinal,self.__jMax - 1][0]
        jCur = matrixP[iFinal,self.__jMax - 1][1]

        for j in range(self.__jMax-2,-1,-1):

            revOutput.append(self.__tagLookup[iCur])
            iCurOld = iCur
            iCur = matrixP[iCur,jCur][0]
            jCur = matrixP[iCurOld,jCur][1]

        return revOutput[::-1]


    #outputs the observation sequence in conjunction with the tag sequence
    def __printOutput(self,tagSeq):
        print("Observation | POS Tag")
        print("----------------------")
        for i in range(0,self.__jMax): # len obs
            if(len(self.__obs[i]) > 7):
                tab = '\t'
            else:
                tab = '\t\t'
            print(self.__obs[i] + tab + tagSeq[i])
        return


    # combines tag sequence and observation to be a list of tuples.
    # obersvation is first in tup, tag is second.
    # used to create return value for 'tagSequence()'.
    def __buildTups(self, tagSeq):
        newTups = []

        if(len(self.__obs) != len(tagSeq)):
            print "tag sequence different length than observation sequence"
        else:

            for i in range(0, len(tagSeq)):
                tup = (self.__obs[i], tagSeq[i])
                newTups.append(tup)

        return newTups


    # imports the observation content from a file. Returns contents
    # as a list. Only imports the observations of the file.
    def __getFileContents(self, testFile):
        rawFile = open(testFile,'r')
        obs = []

        for line in rawFile:
            newLine = line.strip('\n')
            newLine = newLine.split(' ')
            obs.append(newLine[0]) # first element is the observation

        return obs


    # splits the full observation list into a list of sequences for easier
    # input into the tagSequence function. Returns list of lists.
    def __splitObs(self, AllObs):
        newSeqLst= []
        startPtr = 0
        endPtr = 0

        for i in range(0, len(AllObs)):
            endPtr = i

            if(self.__isTriggerObs(AllObs[i])):

                tmpLst = AllObs[startPtr:(i+1)]
                newSeqLst.append(tmpLst)
                startPtr = i + 1

        if(startPtr - 1 == endPtr): # edge case, when AllObs does not end in trigger
            newSeqLst.append(AllObs[startPtr:])
        return newSeqLst


    # checks to see of the observation marks the end of a 'sentence'.
    # True if it marks the end, false otherwise.
    def __isTriggerObs(self, obs):
        triggerLst = [".", ",", "?", "!"]
        if obs in triggerLst:
            return True

        return False


    # outputs finalTups into outFile. Maintians same output format as the
    # testing and training sets for easy comparison.
    def __outputTaggedSeq(self, outFile, finalTups):
        fout = open(outFile, 'w')

        for sequence in finalTups:
            for tup in sequence:
                fout.write(tup[0])
                fout.write(" ")
                fout.write(tup[1])
                fout.write('\n')
        fout.close()


    # runs a simple test of tagSequence()
    def simpleTest(self):
        ps = POStagger()

        line = "raise your right hand ."
        seq  = line.split(' ')

        tagged = ps.tagSequence(seq)

        line = "hand me the book ."
        seq  = line.split(' ')
        tagged2 = ps.tagSequence(seq)

        print tagged
        print
        print tagged2

# for running functionality tests.
if(__name__ == "__main__"):
    ps = POStagger()
    inFile = "./wordSets/brown_test.txt"
    outFile = "./wordSets/POStagged.txt"

    if(raw_input("Enter 's' for simple test: ") == 's'):
        ps.simpleTest()
    else:
        print("Current file: " + inFile)
        choice = raw_input("Enter 'c' to change: ")
        if(choice == 'c'):
            inFile = raw_input("Enter file name: ")

        ps.tagAllFile(inFile, outFile)
