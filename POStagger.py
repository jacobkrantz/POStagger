import sys
import numpy as np
np.set_printoptions(threshold=np.nan)
'''
fileName: POStagger.py
Names:    Jacob Krantz, Max Dulin
Date:     11/19/16

* probabilistic part of speech tagger: implements HMM, Viterbi Algorithm
to run:   -requires matrixA.txt matrixB.txt tagLookup.txt
           tagProb.txt wordLookup.txt
          -python2.7
          -command line argument: string of text to be tagged.
           ex: "tag these words"
          -defaults to internal string when no argument given
'''

#takes command line argument as observation sequence. case sensitive.
def getObs():
    obs = []
    args = len(sys.argv)
    if(args == 2):
        s = sys.argv[1]
    else:
        if(args > 2):
            print("Error: too many arguments. Defaulting...")
        s = "I want to go to the race"
    s = s.split(' ')
    for item in s:
        obs.append(item)
    return obs


#inputs a matrix generated by numpy
def getMatrix(fileName):
    try:
        matrix = np.loadtxt(fileName, dtype = 'float')
    except:
        print(fileName +" does not exist or is corrupt. try running buildMatrices.py")
        sys.exit(0)
    return matrix


#imports the lookup list for a given item (either tags or words)
def getLookup(fileName):
    lookup = []
    try:
        rawFile = open(fileName,'r')
        for line in rawFile:
            item = line.strip('\n')
            lookup.append(item)
    except IOError:
        print(fileName + " does not exist or is corrupt.")
        sys.exit(0)
    return lookup


#imports a file containing a dictionary where KEY=tag VALUE=tagCount
def getTagProb(fileName):
    tagProb = {}
    try:
        tagFile = open(fileName,'r')
        for line in tagFile:
            newLine = line.split(' ')
            tagProb[newLine[0]] = float(newLine[1])
    except IOError:
        print(fileName + " does not exist or is corrupt.")
        sys.exit(0)
    return tagProb

#checks if all entered observations exist in the HMM
def isValidObs(obs,wordLookup):
    try:
        for i in range(0,len(obs)):
            problemWord = obs[i]
            wordLookup.index(obs[i])

    except ValueError:
        return False, problemWord

    return True, ''


#constructs Viterbi and backpointer matrices for determining correct tag sequence
def buildMatrixV(matrixA,matrixB,tagLookup,wordLookup,obs,tagProb):
    iMax = len(tagLookup)
    jMax = len(obs)
    matrixV = np.zeros((iMax,jMax), dtype=np.float) # Viterbi matrix
    matrixP = np.zeros((iMax,jMax), dtype='int,int') # backpointer matrix

    for i in range(0,iMax):                #initialization step
        obsIndex = wordLookup.index(obs[0])
        matrixV[i,0] = matrixB[i,obsIndex]

    for j in range(1,jMax):                #iterative step
        obsWord = wordLookup.index(obs[j])
        for i in range(0,iMax):
            curProb = 0
            maxProb = 0
            iBack = 0
            jBack = 0
            for oldI in range(0,iMax):
                Bword = wordLookup[j]
                curProb = matrixV[oldI,j-1] * matrixA[oldI,i] * matrixB[i,obsWord]

                if (curProb > maxProb):
                    maxProb = curProb
                    iBack = oldI
                    jBack = j - 1

            matrixV[i,j] = maxProb
            matrixP[i,j][0] = iBack
            matrixP[i,j][1] = jBack

    return matrixV, matrixP


#traces through the backpointer matrix P and catches
#the most likely tag sequence as it iterates
def getOutput(matrixV, matrixP,iMax,jMax,tagLookup):
    revOutput = []

    maxFinal = 0
    iFinal = 0

    for i in range(0,iMax):         #only grabs final max prob
        currentFinal = matrixV[i,jMax - 1]
        if(currentFinal > maxFinal):
            maxFinal = currentFinal
            iFinal = i

    revOutput.append(tagLookup[iFinal])
    iCur = matrixP[iFinal,jMax - 1][0]
    jCur = matrixP[iFinal,jMax - 1][1]

    for j in range(jMax-2,-1,-1):

        revOutput.append(tagLookup[iCur])
        iCurOld = iCur
        iCur = matrixP[iCur,jCur][0]
        jCur = matrixP[iCurOld,jCur][1]

    return revOutput[::-1]

#outputs the observation sequence in conjunction with the tag sequence
def printOutput(obs,tagSeq):
    print("Observation | POS Tag")
    print("----------------------")
    for i in range(0,len(obs) ):
        if(len(obs[i]) > 7):
            tab = '\t'
        else:
            tab = '\t\t'
        print(obs[i] + tab + tagSeq[i])
    return


def main():
    obs = getObs()
    wordLookup = getLookup("./wordSets/wordLookup.txt")
    isValid,problemWord = isValidObs(obs,wordLookup)

    if(isValid):
        tagLookup = getLookup("./wordSets/tagLookup.txt")
        tagProb = getTagProb("./wordSets/tagProb.txt")
        matrixA = getMatrix("./wordSets/matrixA.txt")
        matrixB = getMatrix("./wordSets/matrixB.txt")

        matrixV,matrixP = buildMatrixV(matrixA,matrixB,tagLookup,wordLookup,obs,tagProb)

        iMax = len(tagLookup)
        jMax = len(obs)
        tagSeq = getOutput(matrixV,matrixP,iMax,jMax,tagLookup)
        printOutput(obs,tagSeq)
    else:
        print("Error: '" + problemWord + "' does not exist in training set.")

main()
